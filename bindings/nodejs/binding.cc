/*  =========================================================================
    zebra Node.js binding implementation

    Copyright (c) the Contributors as noted in the AUTHORS file.       
    This file is part of ZEBRA.                                        
                                                                       
    This Source Code Form is subject to the terms of the Mozilla Public
    License, v. 2.0. If a copy of the MPL was not distributed with this
    file, You can obtain one at http://mozilla.org/MPL/2.0/.           

################################################################################
#  THIS FILE IS 100% GENERATED BY ZPROJECT; DO NOT EDIT EXCEPT EXPERIMENTALLY  #
#  Read the zproject/README.md for information about making permanent changes. #
################################################################################
    =========================================================================
*/

#include "binding.h"

using namespace v8;
using namespace Nan;

NAN_MODULE_INIT (XrapMsg::Init) {
    Nan::HandleScope scope;

    // Prepare constructor template
    Local <FunctionTemplate> tpl = Nan::New <FunctionTemplate> (New);
    tpl->SetClassName (Nan::New ("XrapMsg").ToLocalChecked ());
    tpl->InstanceTemplate ()->SetInternalFieldCount (1);

    // Prototypes
    Nan::SetPrototypeMethod (tpl, "destroy", destroy);
    Nan::SetPrototypeMethod (tpl, "defined", defined);
    Nan::SetPrototypeMethod (tpl, "decode", _decode);
    Nan::SetPrototypeMethod (tpl, "encode", _encode);
    Nan::SetPrototypeMethod (tpl, "id", _id);
    Nan::SetPrototypeMethod (tpl, "setId", _set_id);
    Nan::SetPrototypeMethod (tpl, "parent", _parent);
    Nan::SetPrototypeMethod (tpl, "setParent", _set_parent);
    Nan::SetPrototypeMethod (tpl, "contentType", _content_type);
    Nan::SetPrototypeMethod (tpl, "setContentType", _set_content_type);
    Nan::SetPrototypeMethod (tpl, "contentBody", _content_body);
    Nan::SetPrototypeMethod (tpl, "setContentBody", _set_content_body);
    Nan::SetPrototypeMethod (tpl, "statusCode", _status_code);
    Nan::SetPrototypeMethod (tpl, "setStatusCode", _set_status_code);
    Nan::SetPrototypeMethod (tpl, "location", _location);
    Nan::SetPrototypeMethod (tpl, "setLocation", _set_location);
    Nan::SetPrototypeMethod (tpl, "etag", _etag);
    Nan::SetPrototypeMethod (tpl, "setEtag", _set_etag);
    Nan::SetPrototypeMethod (tpl, "dateModified", _date_modified);
    Nan::SetPrototypeMethod (tpl, "setDateModified", _set_date_modified);
    Nan::SetPrototypeMethod (tpl, "resource", _resource);
    Nan::SetPrototypeMethod (tpl, "setResource", _set_resource);
    Nan::SetPrototypeMethod (tpl, "parameters", _parameters);
    Nan::SetPrototypeMethod (tpl, "getParameters", _get_parameters);
    Nan::SetPrototypeMethod (tpl, "setParameters", _set_parameters);
    Nan::SetPrototypeMethod (tpl, "parametersString", _parameters_string);
    Nan::SetPrototypeMethod (tpl, "parametersInsert", _parameters_insert);
    Nan::SetPrototypeMethod (tpl, "ifModifiedSince", _if_modified_since);
    Nan::SetPrototypeMethod (tpl, "setIfModifiedSince", _set_if_modified_since);
    Nan::SetPrototypeMethod (tpl, "ifNoneMatch", _if_none_match);
    Nan::SetPrototypeMethod (tpl, "setIfNoneMatch", _set_if_none_match);
    Nan::SetPrototypeMethod (tpl, "metadata", _metadata);
    Nan::SetPrototypeMethod (tpl, "getMetadata", _get_metadata);
    Nan::SetPrototypeMethod (tpl, "setMetadata", _set_metadata);
    Nan::SetPrototypeMethod (tpl, "metadataString", _metadata_string);
    Nan::SetPrototypeMethod (tpl, "metadataInsert", _metadata_insert);
    Nan::SetPrototypeMethod (tpl, "ifUnmodifiedSince", _if_unmodified_since);
    Nan::SetPrototypeMethod (tpl, "setIfUnmodifiedSince", _set_if_unmodified_since);
    Nan::SetPrototypeMethod (tpl, "ifMatch", _if_match);
    Nan::SetPrototypeMethod (tpl, "setIfMatch", _set_if_match);
    Nan::SetPrototypeMethod (tpl, "statusText", _status_text);
    Nan::SetPrototypeMethod (tpl, "setStatusText", _set_status_text);
    Nan::SetPrototypeMethod (tpl, "test", _test);

    constructor ().Reset (Nan::GetFunction (tpl).ToLocalChecked ());
    Nan::Set (target, Nan::New ("XrapMsg").ToLocalChecked (),
    Nan::GetFunction (tpl).ToLocalChecked ());
}

XrapMsg::XrapMsg (int id) {
    self = xrap_msg_new ((int) id);
}

XrapMsg::XrapMsg (xrap_msg_t *self_) {
    self = self_;
}

XrapMsg::~XrapMsg () {
}

NAN_METHOD (XrapMsg::New) {
    assert (info.IsConstructCall ());
    if (info [0]->IsUndefined ())
        return Nan::ThrowTypeError ("method requires a `id`");

    int id;
    if (info [0]->IsNumber ())
        id = Nan::To<int>(info [0]).FromJust ();
    else
        return Nan::ThrowTypeError ("`id` must be a number");
    XrapMsg *xrap_msg = new XrapMsg ((int) id);
    if (xrap_msg) {
        xrap_msg->Wrap (info.This ());
        info.GetReturnValue ().Set (info.This ());
    }
}

NAN_METHOD (XrapMsg::destroy) {
    XrapMsg *xrap_msg = Nan::ObjectWrap::Unwrap <XrapMsg> (info.Holder ());
    xrap_msg_destroy (&xrap_msg->self);
}


NAN_METHOD (XrapMsg::defined) {
    XrapMsg *xrap_msg = Nan::ObjectWrap::Unwrap <XrapMsg> (info.Holder ());
    info.GetReturnValue ().Set (Nan::New (xrap_msg->self != NULL));
}

NAN_METHOD (XrapMsg::_decode) {
    Zmsg *msg_p = Nan::ObjectWrap::Unwrap<Zmsg>(info [0].As<Object>());
    xrap_msg_t *result = xrap_msg_decode (&msg_p->self);
    XrapMsg *xrap_msg_result = new XrapMsg (result);
    if (xrap_msg_result) {
    //  Don't yet know how to return a new object
    //      xrap_msg->Wrap (info.This ());
    //      info.GetReturnValue ().Set (info.This ());
        info.GetReturnValue ().Set (Nan::New<Boolean>(true));
    }
}

NAN_METHOD (XrapMsg::_encode) {
    XrapMsg *xrap_msg_p = Nan::ObjectWrap::Unwrap<XrapMsg>(info [0].As<Object>());
    zmsg_t *result = xrap_msg_encode (&xrap_msg_p->self);
    Zmsg *zmsg_result = new Zmsg (result);
    if (zmsg_result) {
    //  Don't yet know how to return a new object
    //      zmsg->Wrap (info.This ());
    //      info.GetReturnValue ().Set (info.This ());
        info.GetReturnValue ().Set (Nan::New<Boolean>(true));
    }
}

NAN_METHOD (XrapMsg::_id) {
    XrapMsg *xrap_msg = Nan::ObjectWrap::Unwrap <XrapMsg> (info.Holder ());
    int result = xrap_msg_id (xrap_msg->self);
    info.GetReturnValue ().Set (Nan::New<Number>(result));
}

NAN_METHOD (XrapMsg::_set_id) {
    XrapMsg *xrap_msg = Nan::ObjectWrap::Unwrap <XrapMsg> (info.Holder ());
    if (info [0]->IsUndefined ())
        return Nan::ThrowTypeError ("method requires a `id`");

    int id;
    if (info [0]->IsNumber ())
        id = Nan::To<int>(info [0]).FromJust ();
    else
        return Nan::ThrowTypeError ("`id` must be a number");
    xrap_msg_set_id (xrap_msg->self, (int) id);
}

NAN_METHOD (XrapMsg::_parent) {
    XrapMsg *xrap_msg = Nan::ObjectWrap::Unwrap <XrapMsg> (info.Holder ());
    char *result = (char *) xrap_msg_parent (xrap_msg->self);
    info.GetReturnValue ().Set (Nan::New (result).ToLocalChecked ());
}

NAN_METHOD (XrapMsg::_set_parent) {
    XrapMsg *xrap_msg = Nan::ObjectWrap::Unwrap <XrapMsg> (info.Holder ());
    char *format;
    if (info [0]->IsUndefined ())
        return Nan::ThrowTypeError ("method requires a `format`");
    else
    if (!info [0]->IsString ())
        return Nan::ThrowTypeError ("`format` must be a string");
    else {
        Nan::Utf8String format_utf8 (info [0].As<String>());
        format = *format_utf8;
    }
    xrap_msg_set_parent (xrap_msg->self, "%s", format);
}

NAN_METHOD (XrapMsg::_content_type) {
    XrapMsg *xrap_msg = Nan::ObjectWrap::Unwrap <XrapMsg> (info.Holder ());
    char *result = (char *) xrap_msg_content_type (xrap_msg->self);
    info.GetReturnValue ().Set (Nan::New (result).ToLocalChecked ());
}

NAN_METHOD (XrapMsg::_set_content_type) {
    XrapMsg *xrap_msg = Nan::ObjectWrap::Unwrap <XrapMsg> (info.Holder ());
    char *format;
    if (info [0]->IsUndefined ())
        return Nan::ThrowTypeError ("method requires a `format`");
    else
    if (!info [0]->IsString ())
        return Nan::ThrowTypeError ("`format` must be a string");
    else {
        Nan::Utf8String format_utf8 (info [0].As<String>());
        format = *format_utf8;
    }
    xrap_msg_set_content_type (xrap_msg->self, "%s", format);
}

NAN_METHOD (XrapMsg::_content_body) {
    XrapMsg *xrap_msg = Nan::ObjectWrap::Unwrap <XrapMsg> (info.Holder ());
    char *result = (char *) xrap_msg_content_body (xrap_msg->self);
    info.GetReturnValue ().Set (Nan::New (result).ToLocalChecked ());
}

NAN_METHOD (XrapMsg::_set_content_body) {
    XrapMsg *xrap_msg = Nan::ObjectWrap::Unwrap <XrapMsg> (info.Holder ());
    char *format;
    if (info [0]->IsUndefined ())
        return Nan::ThrowTypeError ("method requires a `format`");
    else
    if (!info [0]->IsString ())
        return Nan::ThrowTypeError ("`format` must be a string");
    else {
        Nan::Utf8String format_utf8 (info [0].As<String>());
        format = *format_utf8;
    }
    xrap_msg_set_content_body (xrap_msg->self, "%s", format);
}

NAN_METHOD (XrapMsg::_status_code) {
    XrapMsg *xrap_msg = Nan::ObjectWrap::Unwrap <XrapMsg> (info.Holder ());
    uint16_t result = xrap_msg_status_code (xrap_msg->self);
    info.GetReturnValue ().Set (Nan::New<Number>(result));
}

NAN_METHOD (XrapMsg::_set_status_code) {
    XrapMsg *xrap_msg = Nan::ObjectWrap::Unwrap <XrapMsg> (info.Holder ());
    if (info [0]->IsUndefined ())
        return Nan::ThrowTypeError ("method requires a `status code`");

    uint16_t status_code;
    if (info [0]->IsNumber ())
        status_code = Nan::To<uint32_t>(info [0]).FromJust ();
    else
        return Nan::ThrowTypeError ("`status code` must be a number");
    xrap_msg_set_status_code (xrap_msg->self, (uint16_t) status_code);
}

NAN_METHOD (XrapMsg::_location) {
    XrapMsg *xrap_msg = Nan::ObjectWrap::Unwrap <XrapMsg> (info.Holder ());
    char *result = (char *) xrap_msg_location (xrap_msg->self);
    info.GetReturnValue ().Set (Nan::New (result).ToLocalChecked ());
}

NAN_METHOD (XrapMsg::_set_location) {
    XrapMsg *xrap_msg = Nan::ObjectWrap::Unwrap <XrapMsg> (info.Holder ());
    char *format;
    if (info [0]->IsUndefined ())
        return Nan::ThrowTypeError ("method requires a `format`");
    else
    if (!info [0]->IsString ())
        return Nan::ThrowTypeError ("`format` must be a string");
    else {
        Nan::Utf8String format_utf8 (info [0].As<String>());
        format = *format_utf8;
    }
    xrap_msg_set_location (xrap_msg->self, "%s", format);
}

NAN_METHOD (XrapMsg::_etag) {
    XrapMsg *xrap_msg = Nan::ObjectWrap::Unwrap <XrapMsg> (info.Holder ());
    char *result = (char *) xrap_msg_etag (xrap_msg->self);
    info.GetReturnValue ().Set (Nan::New (result).ToLocalChecked ());
}

NAN_METHOD (XrapMsg::_set_etag) {
    XrapMsg *xrap_msg = Nan::ObjectWrap::Unwrap <XrapMsg> (info.Holder ());
    char *format;
    if (info [0]->IsUndefined ())
        return Nan::ThrowTypeError ("method requires a `format`");
    else
    if (!info [0]->IsString ())
        return Nan::ThrowTypeError ("`format` must be a string");
    else {
        Nan::Utf8String format_utf8 (info [0].As<String>());
        format = *format_utf8;
    }
    xrap_msg_set_etag (xrap_msg->self, "%s", format);
}

NAN_METHOD (XrapMsg::_date_modified) {
    XrapMsg *xrap_msg = Nan::ObjectWrap::Unwrap <XrapMsg> (info.Holder ());
    uint64_t result = xrap_msg_date_modified (xrap_msg->self);
    info.GetReturnValue ().Set (Nan::New<Number>(result));
}

NAN_METHOD (XrapMsg::_set_date_modified) {
    XrapMsg *xrap_msg = Nan::ObjectWrap::Unwrap <XrapMsg> (info.Holder ());
    if (info [0]->IsUndefined ())
        return Nan::ThrowTypeError ("method requires a `date modified`");

    uint64_t date_modified;
    if (info [0]->IsNumber ())
        date_modified = Nan::To<int64_t>(info [0]).FromJust ();
    else
        return Nan::ThrowTypeError ("`date modified` must be a number");
    xrap_msg_set_date_modified (xrap_msg->self, (uint64_t) date_modified);
}

NAN_METHOD (XrapMsg::_resource) {
    XrapMsg *xrap_msg = Nan::ObjectWrap::Unwrap <XrapMsg> (info.Holder ());
    char *result = (char *) xrap_msg_resource (xrap_msg->self);
    info.GetReturnValue ().Set (Nan::New (result).ToLocalChecked ());
}

NAN_METHOD (XrapMsg::_set_resource) {
    XrapMsg *xrap_msg = Nan::ObjectWrap::Unwrap <XrapMsg> (info.Holder ());
    char *format;
    if (info [0]->IsUndefined ())
        return Nan::ThrowTypeError ("method requires a `format`");
    else
    if (!info [0]->IsString ())
        return Nan::ThrowTypeError ("`format` must be a string");
    else {
        Nan::Utf8String format_utf8 (info [0].As<String>());
        format = *format_utf8;
    }
    xrap_msg_set_resource (xrap_msg->self, "%s", format);
}

NAN_METHOD (XrapMsg::_parameters) {
    XrapMsg *xrap_msg = Nan::ObjectWrap::Unwrap <XrapMsg> (info.Holder ());
    zhash_t *result = xrap_msg_parameters (xrap_msg->self);
    Zhash *zhash_result = new Zhash (result);
    if (zhash_result) {
    //  Don't yet know how to return a new object
    //      zhash->Wrap (info.This ());
    //      info.GetReturnValue ().Set (info.This ());
        info.GetReturnValue ().Set (Nan::New<Boolean>(true));
    }
}

NAN_METHOD (XrapMsg::_get_parameters) {
    XrapMsg *xrap_msg = Nan::ObjectWrap::Unwrap <XrapMsg> (info.Holder ());
    zhash_t *result = xrap_msg_get_parameters (xrap_msg->self);
    Zhash *zhash_result = new Zhash (result);
    if (zhash_result) {
    //  Don't yet know how to return a new object
    //      zhash->Wrap (info.This ());
    //      info.GetReturnValue ().Set (info.This ());
        info.GetReturnValue ().Set (Nan::New<Boolean>(true));
    }
}

NAN_METHOD (XrapMsg::_set_parameters) {
    XrapMsg *xrap_msg = Nan::ObjectWrap::Unwrap <XrapMsg> (info.Holder ());
    Zhash *parameters_p = Nan::ObjectWrap::Unwrap<Zhash>(info [0].As<Object>());
    xrap_msg_set_parameters (xrap_msg->self, &parameters_p->self);
}

NAN_METHOD (XrapMsg::_parameters_string) {
    XrapMsg *xrap_msg = Nan::ObjectWrap::Unwrap <XrapMsg> (info.Holder ());
    char *key;
    if (info [0]->IsUndefined ())
        return Nan::ThrowTypeError ("method requires a `key`");
    else
    if (!info [0]->IsString ())
        return Nan::ThrowTypeError ("`key` must be a string");
    else {
        Nan::Utf8String key_utf8 (info [0].As<String>());
        key = *key_utf8;
    }
    char *default_value;
    if (info [1]->IsUndefined ())
        return Nan::ThrowTypeError ("method requires a `default_value`");
    else
    if (!info [1]->IsString ())
        return Nan::ThrowTypeError ("`default_value` must be a string");
    else {
        Nan::Utf8String default_value_utf8 (info [1].As<String>());
        default_value = *default_value_utf8;
    }
    char *result = (char *) xrap_msg_parameters_string (xrap_msg->self, (const char *)key, (const char *)default_value);
    info.GetReturnValue ().Set (Nan::New (result).ToLocalChecked ());
}

NAN_METHOD (XrapMsg::_parameters_insert) {
    XrapMsg *xrap_msg = Nan::ObjectWrap::Unwrap <XrapMsg> (info.Holder ());
    char *key;
    if (info [0]->IsUndefined ())
        return Nan::ThrowTypeError ("method requires a `key`");
    else
    if (!info [0]->IsString ())
        return Nan::ThrowTypeError ("`key` must be a string");
    else {
        Nan::Utf8String key_utf8 (info [0].As<String>());
        key = *key_utf8;
    }
    char *format;
    if (info [1]->IsUndefined ())
        return Nan::ThrowTypeError ("method requires a `format`");
    else
    if (!info [1]->IsString ())
        return Nan::ThrowTypeError ("`format` must be a string");
    else {
        Nan::Utf8String format_utf8 (info [1].As<String>());
        format = *format_utf8;
    }
    xrap_msg_parameters_insert (xrap_msg->self, (const char *)key, "%s", format);
}

NAN_METHOD (XrapMsg::_if_modified_since) {
    XrapMsg *xrap_msg = Nan::ObjectWrap::Unwrap <XrapMsg> (info.Holder ());
    uint64_t result = xrap_msg_if_modified_since (xrap_msg->self);
    info.GetReturnValue ().Set (Nan::New<Number>(result));
}

NAN_METHOD (XrapMsg::_set_if_modified_since) {
    XrapMsg *xrap_msg = Nan::ObjectWrap::Unwrap <XrapMsg> (info.Holder ());
    if (info [0]->IsUndefined ())
        return Nan::ThrowTypeError ("method requires a `if modified since`");

    uint64_t if_modified_since;
    if (info [0]->IsNumber ())
        if_modified_since = Nan::To<int64_t>(info [0]).FromJust ();
    else
        return Nan::ThrowTypeError ("`if modified since` must be a number");
    xrap_msg_set_if_modified_since (xrap_msg->self, (uint64_t) if_modified_since);
}

NAN_METHOD (XrapMsg::_if_none_match) {
    XrapMsg *xrap_msg = Nan::ObjectWrap::Unwrap <XrapMsg> (info.Holder ());
    char *result = (char *) xrap_msg_if_none_match (xrap_msg->self);
    info.GetReturnValue ().Set (Nan::New (result).ToLocalChecked ());
}

NAN_METHOD (XrapMsg::_set_if_none_match) {
    XrapMsg *xrap_msg = Nan::ObjectWrap::Unwrap <XrapMsg> (info.Holder ());
    char *format;
    if (info [0]->IsUndefined ())
        return Nan::ThrowTypeError ("method requires a `format`");
    else
    if (!info [0]->IsString ())
        return Nan::ThrowTypeError ("`format` must be a string");
    else {
        Nan::Utf8String format_utf8 (info [0].As<String>());
        format = *format_utf8;
    }
    xrap_msg_set_if_none_match (xrap_msg->self, "%s", format);
}

NAN_METHOD (XrapMsg::_metadata) {
    XrapMsg *xrap_msg = Nan::ObjectWrap::Unwrap <XrapMsg> (info.Holder ());
    zhash_t *result = xrap_msg_metadata (xrap_msg->self);
    Zhash *zhash_result = new Zhash (result);
    if (zhash_result) {
    //  Don't yet know how to return a new object
    //      zhash->Wrap (info.This ());
    //      info.GetReturnValue ().Set (info.This ());
        info.GetReturnValue ().Set (Nan::New<Boolean>(true));
    }
}

NAN_METHOD (XrapMsg::_get_metadata) {
    XrapMsg *xrap_msg = Nan::ObjectWrap::Unwrap <XrapMsg> (info.Holder ());
    zhash_t *result = xrap_msg_get_metadata (xrap_msg->self);
    Zhash *zhash_result = new Zhash (result);
    if (zhash_result) {
    //  Don't yet know how to return a new object
    //      zhash->Wrap (info.This ());
    //      info.GetReturnValue ().Set (info.This ());
        info.GetReturnValue ().Set (Nan::New<Boolean>(true));
    }
}

NAN_METHOD (XrapMsg::_set_metadata) {
    XrapMsg *xrap_msg = Nan::ObjectWrap::Unwrap <XrapMsg> (info.Holder ());
    Zhash *metadata_p = Nan::ObjectWrap::Unwrap<Zhash>(info [0].As<Object>());
    xrap_msg_set_metadata (xrap_msg->self, &metadata_p->self);
}

NAN_METHOD (XrapMsg::_metadata_string) {
    XrapMsg *xrap_msg = Nan::ObjectWrap::Unwrap <XrapMsg> (info.Holder ());
    char *key;
    if (info [0]->IsUndefined ())
        return Nan::ThrowTypeError ("method requires a `key`");
    else
    if (!info [0]->IsString ())
        return Nan::ThrowTypeError ("`key` must be a string");
    else {
        Nan::Utf8String key_utf8 (info [0].As<String>());
        key = *key_utf8;
    }
    char *default_value;
    if (info [1]->IsUndefined ())
        return Nan::ThrowTypeError ("method requires a `default_value`");
    else
    if (!info [1]->IsString ())
        return Nan::ThrowTypeError ("`default_value` must be a string");
    else {
        Nan::Utf8String default_value_utf8 (info [1].As<String>());
        default_value = *default_value_utf8;
    }
    char *result = (char *) xrap_msg_metadata_string (xrap_msg->self, (const char *)key, (const char *)default_value);
    info.GetReturnValue ().Set (Nan::New (result).ToLocalChecked ());
}

NAN_METHOD (XrapMsg::_metadata_insert) {
    XrapMsg *xrap_msg = Nan::ObjectWrap::Unwrap <XrapMsg> (info.Holder ());
    char *key;
    if (info [0]->IsUndefined ())
        return Nan::ThrowTypeError ("method requires a `key`");
    else
    if (!info [0]->IsString ())
        return Nan::ThrowTypeError ("`key` must be a string");
    else {
        Nan::Utf8String key_utf8 (info [0].As<String>());
        key = *key_utf8;
    }
    char *format;
    if (info [1]->IsUndefined ())
        return Nan::ThrowTypeError ("method requires a `format`");
    else
    if (!info [1]->IsString ())
        return Nan::ThrowTypeError ("`format` must be a string");
    else {
        Nan::Utf8String format_utf8 (info [1].As<String>());
        format = *format_utf8;
    }
    xrap_msg_metadata_insert (xrap_msg->self, (const char *)key, "%s", format);
}

NAN_METHOD (XrapMsg::_if_unmodified_since) {
    XrapMsg *xrap_msg = Nan::ObjectWrap::Unwrap <XrapMsg> (info.Holder ());
    uint64_t result = xrap_msg_if_unmodified_since (xrap_msg->self);
    info.GetReturnValue ().Set (Nan::New<Number>(result));
}

NAN_METHOD (XrapMsg::_set_if_unmodified_since) {
    XrapMsg *xrap_msg = Nan::ObjectWrap::Unwrap <XrapMsg> (info.Holder ());
    if (info [0]->IsUndefined ())
        return Nan::ThrowTypeError ("method requires a `if unmodified since`");

    uint64_t if_unmodified_since;
    if (info [0]->IsNumber ())
        if_unmodified_since = Nan::To<int64_t>(info [0]).FromJust ();
    else
        return Nan::ThrowTypeError ("`if unmodified since` must be a number");
    xrap_msg_set_if_unmodified_since (xrap_msg->self, (uint64_t) if_unmodified_since);
}

NAN_METHOD (XrapMsg::_if_match) {
    XrapMsg *xrap_msg = Nan::ObjectWrap::Unwrap <XrapMsg> (info.Holder ());
    char *result = (char *) xrap_msg_if_match (xrap_msg->self);
    info.GetReturnValue ().Set (Nan::New (result).ToLocalChecked ());
}

NAN_METHOD (XrapMsg::_set_if_match) {
    XrapMsg *xrap_msg = Nan::ObjectWrap::Unwrap <XrapMsg> (info.Holder ());
    char *format;
    if (info [0]->IsUndefined ())
        return Nan::ThrowTypeError ("method requires a `format`");
    else
    if (!info [0]->IsString ())
        return Nan::ThrowTypeError ("`format` must be a string");
    else {
        Nan::Utf8String format_utf8 (info [0].As<String>());
        format = *format_utf8;
    }
    xrap_msg_set_if_match (xrap_msg->self, "%s", format);
}

NAN_METHOD (XrapMsg::_status_text) {
    XrapMsg *xrap_msg = Nan::ObjectWrap::Unwrap <XrapMsg> (info.Holder ());
    char *result = (char *) xrap_msg_status_text (xrap_msg->self);
    info.GetReturnValue ().Set (Nan::New (result).ToLocalChecked ());
}

NAN_METHOD (XrapMsg::_set_status_text) {
    XrapMsg *xrap_msg = Nan::ObjectWrap::Unwrap <XrapMsg> (info.Holder ());
    char *format;
    if (info [0]->IsUndefined ())
        return Nan::ThrowTypeError ("method requires a `format`");
    else
    if (!info [0]->IsString ())
        return Nan::ThrowTypeError ("`format` must be a string");
    else {
        Nan::Utf8String format_utf8 (info [0].As<String>());
        format = *format_utf8;
    }
    xrap_msg_set_status_text (xrap_msg->self, "%s", format);
}

NAN_METHOD (XrapMsg::_test) {
    if (info [0]->IsUndefined ())
        return Nan::ThrowTypeError ("method requires a `verbose`");

    bool verbose;
    if (info [0]->IsBoolean ())
        verbose = Nan::To<bool>(info [0]).FromJust ();
    else
        return Nan::ThrowTypeError ("`verbose` must be a Boolean");
    xrap_msg_test ((bool) verbose);
}

Nan::Persistent <Function> &XrapMsg::constructor () {
    static Nan::Persistent <Function> my_constructor;
    return my_constructor;
}


NAN_MODULE_INIT (ZebHandler::Init) {
    Nan::HandleScope scope;

    // Prepare constructor template
    Local <FunctionTemplate> tpl = Nan::New <FunctionTemplate> (New);
    tpl->SetClassName (Nan::New ("ZebHandler").ToLocalChecked ());
    tpl->InstanceTemplate ()->SetInternalFieldCount (1);

    // Prototypes
    Nan::SetPrototypeMethod (tpl, "addOffer", _add_offer);
    Nan::SetPrototypeMethod (tpl, "addAccept", _add_accept);
    Nan::SetPrototypeMethod (tpl, "test", _test);

    constructor ().Reset (Nan::GetFunction (tpl).ToLocalChecked ());
    Nan::Set (target, Nan::New ("ZebHandler").ToLocalChecked (),
    Nan::GetFunction (tpl).ToLocalChecked ());
}

ZebHandler::ZebHandler () {
}

ZebHandler::~ZebHandler () {
}

NAN_METHOD (ZebHandler::New) {
    assert (info.IsConstructCall ());
    ZebHandler *zeb_handler = new ZebHandler ();
    if (zeb_handler) {
        zeb_handler->Wrap (info.This ());
        info.GetReturnValue ().Set (info.This ());
    }
}

NAN_METHOD (ZebHandler::_add_offer) {
    Zactor *self = Nan::ObjectWrap::Unwrap<Zactor>(info [0].As<Object>());
    if (info [1]->IsUndefined ())
        return Nan::ThrowTypeError ("method requires a `method`");

    int method;
    if (info [1]->IsNumber ())
        method = Nan::To<int>(info [1]).FromJust ();
    else
        return Nan::ThrowTypeError ("`method` must be a number");
    char *uri;
    if (info [2]->IsUndefined ())
        return Nan::ThrowTypeError ("method requires a `uri`");
    else
    if (!info [2]->IsString ())
        return Nan::ThrowTypeError ("`uri` must be a string");
    else {
        Nan::Utf8String uri_utf8 (info [2].As<String>());
        uri = *uri_utf8;
    }
    int result = zeb_handler_add_offer (self->self, (int) method, (const char *)uri);
    info.GetReturnValue ().Set (Nan::New<Number>(result));
}

NAN_METHOD (ZebHandler::_add_accept) {
    Zactor *self = Nan::ObjectWrap::Unwrap<Zactor>(info [0].As<Object>());
    char *accept;
    if (info [1]->IsUndefined ())
        return Nan::ThrowTypeError ("method requires a `accept`");
    else
    if (!info [1]->IsString ())
        return Nan::ThrowTypeError ("`accept` must be a string");
    else {
        Nan::Utf8String accept_utf8 (info [1].As<String>());
        accept = *accept_utf8;
    }
    int result = zeb_handler_add_accept (self->self, (const char *)accept);
    info.GetReturnValue ().Set (Nan::New<Number>(result));
}

NAN_METHOD (ZebHandler::_test) {
    if (info [0]->IsUndefined ())
        return Nan::ThrowTypeError ("method requires a `verbose`");

    bool verbose;
    if (info [0]->IsBoolean ())
        verbose = Nan::To<bool>(info [0]).FromJust ();
    else
        return Nan::ThrowTypeError ("`verbose` must be a Boolean");
    zeb_handler_test ((bool) verbose);
}

Nan::Persistent <Function> &ZebHandler::constructor () {
    static Nan::Persistent <Function> my_constructor;
    return my_constructor;
}


NAN_MODULE_INIT (XrapTraffic::Init) {
    Nan::HandleScope scope;

    // Prepare constructor template
    Local <FunctionTemplate> tpl = Nan::New <FunctionTemplate> (New);
    tpl->SetClassName (Nan::New ("XrapTraffic").ToLocalChecked ());
    tpl->InstanceTemplate ()->SetInternalFieldCount (1);

    // Prototypes
    Nan::SetPrototypeMethod (tpl, "destroy", destroy);
    Nan::SetPrototypeMethod (tpl, "defined", defined);
    Nan::SetPrototypeMethod (tpl, "recv", _recv);
    Nan::SetPrototypeMethod (tpl, "send", _send);
    Nan::SetPrototypeMethod (tpl, "print", _print);
    Nan::SetPrototypeMethod (tpl, "routingId", _routing_id);
    Nan::SetPrototypeMethod (tpl, "setRoutingId", _set_routing_id);
    Nan::SetPrototypeMethod (tpl, "id", _id);
    Nan::SetPrototypeMethod (tpl, "setId", _set_id);
    Nan::SetPrototypeMethod (tpl, "command", _command);
    Nan::SetPrototypeMethod (tpl, "address", _address);
    Nan::SetPrototypeMethod (tpl, "setAddress", _set_address);
    Nan::SetPrototypeMethod (tpl, "timeout", _timeout);
    Nan::SetPrototypeMethod (tpl, "setTimeout", _set_timeout);
    Nan::SetPrototypeMethod (tpl, "content", _content);
    Nan::SetPrototypeMethod (tpl, "getContent", _get_content);
    Nan::SetPrototypeMethod (tpl, "setContent", _set_content);
    Nan::SetPrototypeMethod (tpl, "route", _route);
    Nan::SetPrototypeMethod (tpl, "setRoute", _set_route);
    Nan::SetPrototypeMethod (tpl, "method", _method);
    Nan::SetPrototypeMethod (tpl, "setMethod", _set_method);
    Nan::SetPrototypeMethod (tpl, "sender", _sender);
    Nan::SetPrototypeMethod (tpl, "getSender", _get_sender);
    Nan::SetPrototypeMethod (tpl, "setSender", _set_sender);
    Nan::SetPrototypeMethod (tpl, "statusCode", _status_code);
    Nan::SetPrototypeMethod (tpl, "setStatusCode", _set_status_code);
    Nan::SetPrototypeMethod (tpl, "statusReason", _status_reason);
    Nan::SetPrototypeMethod (tpl, "setStatusReason", _set_status_reason);
    Nan::SetPrototypeMethod (tpl, "test", _test);

    constructor ().Reset (Nan::GetFunction (tpl).ToLocalChecked ());
    Nan::Set (target, Nan::New ("XrapTraffic").ToLocalChecked (),
    Nan::GetFunction (tpl).ToLocalChecked ());
}

XrapTraffic::XrapTraffic (void) {
    self = xrap_traffic_new ();
}

XrapTraffic::XrapTraffic (xrap_traffic_t *self_) {
    self = self_;
}

XrapTraffic::~XrapTraffic () {
}

NAN_METHOD (XrapTraffic::New) {
    assert (info.IsConstructCall ());
    XrapTraffic *xrap_traffic = new XrapTraffic ();
    if (xrap_traffic) {
        xrap_traffic->Wrap (info.This ());
        info.GetReturnValue ().Set (info.This ());
    }
}

NAN_METHOD (XrapTraffic::destroy) {
    XrapTraffic *xrap_traffic = Nan::ObjectWrap::Unwrap <XrapTraffic> (info.Holder ());
    xrap_traffic_destroy (&xrap_traffic->self);
}


NAN_METHOD (XrapTraffic::defined) {
    XrapTraffic *xrap_traffic = Nan::ObjectWrap::Unwrap <XrapTraffic> (info.Holder ());
    info.GetReturnValue ().Set (Nan::New (xrap_traffic->self != NULL));
}

NAN_METHOD (XrapTraffic::_recv) {
    XrapTraffic *xrap_traffic = Nan::ObjectWrap::Unwrap <XrapTraffic> (info.Holder ());
    Zsock *input = Nan::ObjectWrap::Unwrap<Zsock>(info [0].As<Object>());
    int result = xrap_traffic_recv (xrap_traffic->self, input->self);
    info.GetReturnValue ().Set (Nan::New<Number>(result));
}

NAN_METHOD (XrapTraffic::_send) {
    XrapTraffic *xrap_traffic = Nan::ObjectWrap::Unwrap <XrapTraffic> (info.Holder ());
    Zsock *output = Nan::ObjectWrap::Unwrap<Zsock>(info [0].As<Object>());
    int result = xrap_traffic_send (xrap_traffic->self, output->self);
    info.GetReturnValue ().Set (Nan::New<Number>(result));
}

NAN_METHOD (XrapTraffic::_print) {
    XrapTraffic *xrap_traffic = Nan::ObjectWrap::Unwrap <XrapTraffic> (info.Holder ());
    xrap_traffic_print (xrap_traffic->self);
}

NAN_METHOD (XrapTraffic::_routing_id) {
    XrapTraffic *xrap_traffic = Nan::ObjectWrap::Unwrap <XrapTraffic> (info.Holder ());
    zframe_t *result = xrap_traffic_routing_id (xrap_traffic->self);
    Zframe *zframe_result = new Zframe (result);
    if (zframe_result) {
    //  Don't yet know how to return a new object
    //      zframe->Wrap (info.This ());
    //      info.GetReturnValue ().Set (info.This ());
        info.GetReturnValue ().Set (Nan::New<Boolean>(true));
    }
}

NAN_METHOD (XrapTraffic::_set_routing_id) {
    XrapTraffic *xrap_traffic = Nan::ObjectWrap::Unwrap <XrapTraffic> (info.Holder ());
    Zframe *routing_id = Nan::ObjectWrap::Unwrap<Zframe>(info [0].As<Object>());
    xrap_traffic_set_routing_id (xrap_traffic->self, routing_id->self);
}

NAN_METHOD (XrapTraffic::_id) {
    XrapTraffic *xrap_traffic = Nan::ObjectWrap::Unwrap <XrapTraffic> (info.Holder ());
    int result = xrap_traffic_id (xrap_traffic->self);
    info.GetReturnValue ().Set (Nan::New<Number>(result));
}

NAN_METHOD (XrapTraffic::_set_id) {
    XrapTraffic *xrap_traffic = Nan::ObjectWrap::Unwrap <XrapTraffic> (info.Holder ());
    if (info [0]->IsUndefined ())
        return Nan::ThrowTypeError ("method requires a `id`");

    int id;
    if (info [0]->IsNumber ())
        id = Nan::To<int>(info [0]).FromJust ();
    else
        return Nan::ThrowTypeError ("`id` must be a number");
    xrap_traffic_set_id (xrap_traffic->self, (int) id);
}

NAN_METHOD (XrapTraffic::_command) {
    XrapTraffic *xrap_traffic = Nan::ObjectWrap::Unwrap <XrapTraffic> (info.Holder ());
    char *result = (char *) xrap_traffic_command (xrap_traffic->self);
    info.GetReturnValue ().Set (Nan::New (result).ToLocalChecked ());
}

NAN_METHOD (XrapTraffic::_address) {
    XrapTraffic *xrap_traffic = Nan::ObjectWrap::Unwrap <XrapTraffic> (info.Holder ());
    char *result = (char *) xrap_traffic_address (xrap_traffic->self);
    info.GetReturnValue ().Set (Nan::New (result).ToLocalChecked ());
}

NAN_METHOD (XrapTraffic::_set_address) {
    XrapTraffic *xrap_traffic = Nan::ObjectWrap::Unwrap <XrapTraffic> (info.Holder ());
    char *address;
    if (info [0]->IsUndefined ())
        return Nan::ThrowTypeError ("method requires a `address`");
    else
    if (!info [0]->IsString ())
        return Nan::ThrowTypeError ("`address` must be a string");
    else {
        Nan::Utf8String address_utf8 (info [0].As<String>());
        address = *address_utf8;
    }
    xrap_traffic_set_address (xrap_traffic->self, (const char *)address);
}

NAN_METHOD (XrapTraffic::_timeout) {
    XrapTraffic *xrap_traffic = Nan::ObjectWrap::Unwrap <XrapTraffic> (info.Holder ());
    uint32_t result = xrap_traffic_timeout (xrap_traffic->self);
    info.GetReturnValue ().Set (Nan::New<Number>(result));
}

NAN_METHOD (XrapTraffic::_set_timeout) {
    XrapTraffic *xrap_traffic = Nan::ObjectWrap::Unwrap <XrapTraffic> (info.Holder ());
    if (info [0]->IsUndefined ())
        return Nan::ThrowTypeError ("method requires a `timeout`");

    uint32_t timeout;
    if (info [0]->IsNumber ())
        timeout = Nan::To<uint32_t>(info [0]).FromJust ();
    else
        return Nan::ThrowTypeError ("`timeout` must be a number");
    xrap_traffic_set_timeout (xrap_traffic->self, (uint32_t) timeout);
}

NAN_METHOD (XrapTraffic::_content) {
    XrapTraffic *xrap_traffic = Nan::ObjectWrap::Unwrap <XrapTraffic> (info.Holder ());
    zmsg_t *result = xrap_traffic_content (xrap_traffic->self);
    Zmsg *zmsg_result = new Zmsg (result);
    if (zmsg_result) {
    //  Don't yet know how to return a new object
    //      zmsg->Wrap (info.This ());
    //      info.GetReturnValue ().Set (info.This ());
        info.GetReturnValue ().Set (Nan::New<Boolean>(true));
    }
}

NAN_METHOD (XrapTraffic::_get_content) {
    XrapTraffic *xrap_traffic = Nan::ObjectWrap::Unwrap <XrapTraffic> (info.Holder ());
    zmsg_t *result = xrap_traffic_get_content (xrap_traffic->self);
    Zmsg *zmsg_result = new Zmsg (result);
    if (zmsg_result) {
    //  Don't yet know how to return a new object
    //      zmsg->Wrap (info.This ());
    //      info.GetReturnValue ().Set (info.This ());
        info.GetReturnValue ().Set (Nan::New<Boolean>(true));
    }
}

NAN_METHOD (XrapTraffic::_set_content) {
    XrapTraffic *xrap_traffic = Nan::ObjectWrap::Unwrap <XrapTraffic> (info.Holder ());
    Zmsg *content_p = Nan::ObjectWrap::Unwrap<Zmsg>(info [0].As<Object>());
    xrap_traffic_set_content (xrap_traffic->self, &content_p->self);
}

NAN_METHOD (XrapTraffic::_route) {
    XrapTraffic *xrap_traffic = Nan::ObjectWrap::Unwrap <XrapTraffic> (info.Holder ());
    char *result = (char *) xrap_traffic_route (xrap_traffic->self);
    info.GetReturnValue ().Set (Nan::New (result).ToLocalChecked ());
}

NAN_METHOD (XrapTraffic::_set_route) {
    XrapTraffic *xrap_traffic = Nan::ObjectWrap::Unwrap <XrapTraffic> (info.Holder ());
    char *route;
    if (info [0]->IsUndefined ())
        return Nan::ThrowTypeError ("method requires a `route`");
    else
    if (!info [0]->IsString ())
        return Nan::ThrowTypeError ("`route` must be a string");
    else {
        Nan::Utf8String route_utf8 (info [0].As<String>());
        route = *route_utf8;
    }
    xrap_traffic_set_route (xrap_traffic->self, (const char *)route);
}

NAN_METHOD (XrapTraffic::_method) {
    XrapTraffic *xrap_traffic = Nan::ObjectWrap::Unwrap <XrapTraffic> (info.Holder ());
    char *result = (char *) xrap_traffic_method (xrap_traffic->self);
    info.GetReturnValue ().Set (Nan::New (result).ToLocalChecked ());
}

NAN_METHOD (XrapTraffic::_set_method) {
    XrapTraffic *xrap_traffic = Nan::ObjectWrap::Unwrap <XrapTraffic> (info.Holder ());
    char *method;
    if (info [0]->IsUndefined ())
        return Nan::ThrowTypeError ("method requires a `method`");
    else
    if (!info [0]->IsString ())
        return Nan::ThrowTypeError ("`method` must be a string");
    else {
        Nan::Utf8String method_utf8 (info [0].As<String>());
        method = *method_utf8;
    }
    xrap_traffic_set_method (xrap_traffic->self, (const char *)method);
}

NAN_METHOD (XrapTraffic::_sender) {
    XrapTraffic *xrap_traffic = Nan::ObjectWrap::Unwrap <XrapTraffic> (info.Holder ());
    zuuid_t *result = xrap_traffic_sender (xrap_traffic->self);
    Zuuid *zuuid_result = new Zuuid (result);
    if (zuuid_result) {
    //  Don't yet know how to return a new object
    //      zuuid->Wrap (info.This ());
    //      info.GetReturnValue ().Set (info.This ());
        info.GetReturnValue ().Set (Nan::New<Boolean>(true));
    }
}

NAN_METHOD (XrapTraffic::_get_sender) {
    XrapTraffic *xrap_traffic = Nan::ObjectWrap::Unwrap <XrapTraffic> (info.Holder ());
    zuuid_t *result = xrap_traffic_get_sender (xrap_traffic->self);
    Zuuid *zuuid_result = new Zuuid (result);
    if (zuuid_result) {
    //  Don't yet know how to return a new object
    //      zuuid->Wrap (info.This ());
    //      info.GetReturnValue ().Set (info.This ());
        info.GetReturnValue ().Set (Nan::New<Boolean>(true));
    }
}

NAN_METHOD (XrapTraffic::_set_sender) {
    XrapTraffic *xrap_traffic = Nan::ObjectWrap::Unwrap <XrapTraffic> (info.Holder ());
    Zuuid *sender_p = Nan::ObjectWrap::Unwrap<Zuuid>(info [0].As<Object>());
    xrap_traffic_set_sender (xrap_traffic->self, sender_p->self);
}

NAN_METHOD (XrapTraffic::_status_code) {
    XrapTraffic *xrap_traffic = Nan::ObjectWrap::Unwrap <XrapTraffic> (info.Holder ());
    uint16_t result = xrap_traffic_status_code (xrap_traffic->self);
    info.GetReturnValue ().Set (Nan::New<Number>(result));
}

NAN_METHOD (XrapTraffic::_set_status_code) {
    XrapTraffic *xrap_traffic = Nan::ObjectWrap::Unwrap <XrapTraffic> (info.Holder ());
    if (info [0]->IsUndefined ())
        return Nan::ThrowTypeError ("method requires a `status_code`");

    uint16_t status_code;
    if (info [0]->IsNumber ())
        status_code = Nan::To<uint32_t>(info [0]).FromJust ();
    else
        return Nan::ThrowTypeError ("`status_code` must be a number");
    xrap_traffic_set_status_code (xrap_traffic->self, (uint16_t) status_code);
}

NAN_METHOD (XrapTraffic::_status_reason) {
    XrapTraffic *xrap_traffic = Nan::ObjectWrap::Unwrap <XrapTraffic> (info.Holder ());
    char *result = (char *) xrap_traffic_status_reason (xrap_traffic->self);
    info.GetReturnValue ().Set (Nan::New (result).ToLocalChecked ());
}

NAN_METHOD (XrapTraffic::_set_status_reason) {
    XrapTraffic *xrap_traffic = Nan::ObjectWrap::Unwrap <XrapTraffic> (info.Holder ());
    char *status_reason;
    if (info [0]->IsUndefined ())
        return Nan::ThrowTypeError ("method requires a `status_reason`");
    else
    if (!info [0]->IsString ())
        return Nan::ThrowTypeError ("`status_reason` must be a string");
    else {
        Nan::Utf8String status_reason_utf8 (info [0].As<String>());
        status_reason = *status_reason_utf8;
    }
    xrap_traffic_set_status_reason (xrap_traffic->self, (const char *)status_reason);
}

NAN_METHOD (XrapTraffic::_test) {
    if (info [0]->IsUndefined ())
        return Nan::ThrowTypeError ("method requires a `verbose`");

    bool verbose;
    if (info [0]->IsBoolean ())
        verbose = Nan::To<bool>(info [0]).FromJust ();
    else
        return Nan::ThrowTypeError ("`verbose` must be a Boolean");
    xrap_traffic_test ((bool) verbose);
}

Nan::Persistent <Function> &XrapTraffic::constructor () {
    static Nan::Persistent <Function> my_constructor;
    return my_constructor;
}


NAN_MODULE_INIT (ZebClient::Init) {
    Nan::HandleScope scope;

    // Prepare constructor template
    Local <FunctionTemplate> tpl = Nan::New <FunctionTemplate> (New);
    tpl->SetClassName (Nan::New ("ZebClient").ToLocalChecked ());
    tpl->InstanceTemplate ()->SetInternalFieldCount (1);

    // Prototypes
    Nan::SetPrototypeMethod (tpl, "destroy", destroy);
    Nan::SetPrototypeMethod (tpl, "defined", defined);
    Nan::SetPrototypeMethod (tpl, "actor", _actor);
    Nan::SetPrototypeMethod (tpl, "msgpipe", _msgpipe);
    Nan::SetPrototypeMethod (tpl, "connected", _connected);
    Nan::SetPrototypeMethod (tpl, "connect", _connect);
    Nan::SetPrototypeMethod (tpl, "setHandler", _set_handler);
    Nan::SetPrototypeMethod (tpl, "request", _request);
    Nan::SetPrototypeMethod (tpl, "deliver", _deliver);
    Nan::SetPrototypeMethod (tpl, "recv", _recv);
    Nan::SetPrototypeMethod (tpl, "command", _command);
    Nan::SetPrototypeMethod (tpl, "status", _status);
    Nan::SetPrototypeMethod (tpl, "reason", _reason);
    Nan::SetPrototypeMethod (tpl, "sender", _sender);
    Nan::SetPrototypeMethod (tpl, "content", _content);
    Nan::SetPrototypeMethod (tpl, "setVerbose", _set_verbose);
    Nan::SetPrototypeMethod (tpl, "test", _test);

    constructor ().Reset (Nan::GetFunction (tpl).ToLocalChecked ());
    Nan::Set (target, Nan::New ("ZebClient").ToLocalChecked (),
    Nan::GetFunction (tpl).ToLocalChecked ());
}

ZebClient::ZebClient (void) {
    self = zeb_client_new ();
}

ZebClient::ZebClient (zeb_client_t *self_) {
    self = self_;
}

ZebClient::~ZebClient () {
}

NAN_METHOD (ZebClient::New) {
    assert (info.IsConstructCall ());
    ZebClient *zeb_client = new ZebClient ();
    if (zeb_client) {
        zeb_client->Wrap (info.This ());
        info.GetReturnValue ().Set (info.This ());
    }
}

NAN_METHOD (ZebClient::destroy) {
    ZebClient *zeb_client = Nan::ObjectWrap::Unwrap <ZebClient> (info.Holder ());
    zeb_client_destroy (&zeb_client->self);
}


NAN_METHOD (ZebClient::defined) {
    ZebClient *zeb_client = Nan::ObjectWrap::Unwrap <ZebClient> (info.Holder ());
    info.GetReturnValue ().Set (Nan::New (zeb_client->self != NULL));
}

NAN_METHOD (ZebClient::_actor) {
    ZebClient *zeb_client = Nan::ObjectWrap::Unwrap <ZebClient> (info.Holder ());
    zactor_t *result = zeb_client_actor (zeb_client->self);
    Zactor *zactor_result = new Zactor (result);
    if (zactor_result) {
    //  Don't yet know how to return a new object
    //      zactor->Wrap (info.This ());
    //      info.GetReturnValue ().Set (info.This ());
        info.GetReturnValue ().Set (Nan::New<Boolean>(true));
    }
}

NAN_METHOD (ZebClient::_msgpipe) {
    ZebClient *zeb_client = Nan::ObjectWrap::Unwrap <ZebClient> (info.Holder ());
    zsock_t *result = zeb_client_msgpipe (zeb_client->self);
    Zsock *zsock_result = new Zsock (result);
    if (zsock_result) {
    //  Don't yet know how to return a new object
    //      zsock->Wrap (info.This ());
    //      info.GetReturnValue ().Set (info.This ());
        info.GetReturnValue ().Set (Nan::New<Boolean>(true));
    }
}

NAN_METHOD (ZebClient::_connected) {
    ZebClient *zeb_client = Nan::ObjectWrap::Unwrap <ZebClient> (info.Holder ());
    bool result = zeb_client_connected (zeb_client->self);
    info.GetReturnValue ().Set (Nan::New<Boolean>(result));
}

NAN_METHOD (ZebClient::_connect) {
    ZebClient *zeb_client = Nan::ObjectWrap::Unwrap <ZebClient> (info.Holder ());
    char *endpoint;
    if (info [0]->IsUndefined ())
        return Nan::ThrowTypeError ("method requires a `endpoint`");
    else
    if (!info [0]->IsString ())
        return Nan::ThrowTypeError ("`endpoint` must be a string");
    else {
        Nan::Utf8String endpoint_utf8 (info [0].As<String>());
        endpoint = *endpoint_utf8;
    }
    if (info [1]->IsUndefined ())
        return Nan::ThrowTypeError ("method requires a `timeout`");

    uint32_t timeout;
    if (info [1]->IsNumber ())
        timeout = Nan::To<uint32_t>(info [1]).FromJust ();
    else
        return Nan::ThrowTypeError ("`timeout` must be a number");
    char *address;
    if (info [2]->IsUndefined ())
        return Nan::ThrowTypeError ("method requires a `address`");
    else
    if (!info [2]->IsString ())
        return Nan::ThrowTypeError ("`address` must be a string");
    else {
        Nan::Utf8String address_utf8 (info [2].As<String>());
        address = *address_utf8;
    }
    int result = zeb_client_connect (zeb_client->self, (const char *)endpoint, (uint32_t) timeout, (const char *)address);
    info.GetReturnValue ().Set (Nan::New<Number>(result));
}

NAN_METHOD (ZebClient::_set_handler) {
    ZebClient *zeb_client = Nan::ObjectWrap::Unwrap <ZebClient> (info.Holder ());
    char *method;
    if (info [0]->IsUndefined ())
        return Nan::ThrowTypeError ("method requires a `method`");
    else
    if (!info [0]->IsString ())
        return Nan::ThrowTypeError ("`method` must be a string");
    else {
        Nan::Utf8String method_utf8 (info [0].As<String>());
        method = *method_utf8;
    }
    char *route;
    if (info [1]->IsUndefined ())
        return Nan::ThrowTypeError ("method requires a `route`");
    else
    if (!info [1]->IsString ())
        return Nan::ThrowTypeError ("`route` must be a string");
    else {
        Nan::Utf8String route_utf8 (info [1].As<String>());
        route = *route_utf8;
    }
    int result = zeb_client_set_handler (zeb_client->self, (const char *)method, (const char *)route);
    info.GetReturnValue ().Set (Nan::New<Number>(result));
}

NAN_METHOD (ZebClient::_request) {
    ZebClient *zeb_client = Nan::ObjectWrap::Unwrap <ZebClient> (info.Holder ());
    if (info [0]->IsUndefined ())
        return Nan::ThrowTypeError ("method requires a `timeout`");

    uint32_t timeout;
    if (info [0]->IsNumber ())
        timeout = Nan::To<uint32_t>(info [0]).FromJust ();
    else
        return Nan::ThrowTypeError ("`timeout` must be a number");
    Zmsg *content = Nan::ObjectWrap::Unwrap<Zmsg>(info [1].As<Object>());
    int result = zeb_client_request (zeb_client->self, (uint32_t) timeout, &content->self);
    info.GetReturnValue ().Set (Nan::New<Number>(result));
}

NAN_METHOD (ZebClient::_deliver) {
    ZebClient *zeb_client = Nan::ObjectWrap::Unwrap <ZebClient> (info.Holder ());
    Zuuid *sender = Nan::ObjectWrap::Unwrap<Zuuid>(info [0].As<Object>());
    Zmsg *content = Nan::ObjectWrap::Unwrap<Zmsg>(info [1].As<Object>());
    int result = zeb_client_deliver (zeb_client->self, sender->self, &content->self);
    info.GetReturnValue ().Set (Nan::New<Number>(result));
}

NAN_METHOD (ZebClient::_recv) {
    ZebClient *zeb_client = Nan::ObjectWrap::Unwrap <ZebClient> (info.Holder ());
    zmsg_t *result = zeb_client_recv (zeb_client->self);
    Zmsg *zmsg_result = new Zmsg (result);
    if (zmsg_result) {
    //  Don't yet know how to return a new object
    //      zmsg->Wrap (info.This ());
    //      info.GetReturnValue ().Set (info.This ());
        info.GetReturnValue ().Set (Nan::New<Boolean>(true));
    }
}

NAN_METHOD (ZebClient::_command) {
    ZebClient *zeb_client = Nan::ObjectWrap::Unwrap <ZebClient> (info.Holder ());
    char *result = (char *) zeb_client_command (zeb_client->self);
    info.GetReturnValue ().Set (Nan::New (result).ToLocalChecked ());
}

NAN_METHOD (ZebClient::_status) {
    ZebClient *zeb_client = Nan::ObjectWrap::Unwrap <ZebClient> (info.Holder ());
    int result = zeb_client_status (zeb_client->self);
    info.GetReturnValue ().Set (Nan::New<Number>(result));
}

NAN_METHOD (ZebClient::_reason) {
    ZebClient *zeb_client = Nan::ObjectWrap::Unwrap <ZebClient> (info.Holder ());
    char *result = (char *) zeb_client_reason (zeb_client->self);
    info.GetReturnValue ().Set (Nan::New (result).ToLocalChecked ());
}

NAN_METHOD (ZebClient::_sender) {
    ZebClient *zeb_client = Nan::ObjectWrap::Unwrap <ZebClient> (info.Holder ());
    zuuid_t *result = zeb_client_sender (zeb_client->self);
    Zuuid *zuuid_result = new Zuuid (result);
    if (zuuid_result) {
    //  Don't yet know how to return a new object
    //      zuuid->Wrap (info.This ());
    //      info.GetReturnValue ().Set (info.This ());
        info.GetReturnValue ().Set (Nan::New<Boolean>(true));
    }
}

NAN_METHOD (ZebClient::_content) {
    ZebClient *zeb_client = Nan::ObjectWrap::Unwrap <ZebClient> (info.Holder ());
    zmsg_t *result = zeb_client_content (zeb_client->self);
    Zmsg *zmsg_result = new Zmsg (result);
    if (zmsg_result) {
    //  Don't yet know how to return a new object
    //      zmsg->Wrap (info.This ());
    //      info.GetReturnValue ().Set (info.This ());
        info.GetReturnValue ().Set (Nan::New<Boolean>(true));
    }
}

NAN_METHOD (ZebClient::_set_verbose) {
    ZebClient *zeb_client = Nan::ObjectWrap::Unwrap <ZebClient> (info.Holder ());
    if (info [0]->IsUndefined ())
        return Nan::ThrowTypeError ("method requires a `verbose`");

    bool verbose;
    if (info [0]->IsBoolean ())
        verbose = Nan::To<bool>(info [0]).FromJust ();
    else
        return Nan::ThrowTypeError ("`verbose` must be a Boolean");
    zeb_client_set_verbose (zeb_client->self, (bool) verbose);
}

NAN_METHOD (ZebClient::_test) {
    if (info [0]->IsUndefined ())
        return Nan::ThrowTypeError ("method requires a `verbose`");

    bool verbose;
    if (info [0]->IsBoolean ())
        verbose = Nan::To<bool>(info [0]).FromJust ();
    else
        return Nan::ThrowTypeError ("`verbose` must be a Boolean");
    zeb_client_test ((bool) verbose);
}

Nan::Persistent <Function> &ZebClient::constructor () {
    static Nan::Persistent <Function> my_constructor;
    return my_constructor;
}


extern "C" NAN_MODULE_INIT (zebra_initialize)
{
    XrapMsg::Init (target);
    ZebHandler::Init (target);
    XrapTraffic::Init (target);
    ZebClient::Init (target);
}

NODE_MODULE (zebra, zebra_initialize)
