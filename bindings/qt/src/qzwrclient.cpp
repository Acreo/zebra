/*
################################################################################
#  THIS FILE IS 100% GENERATED BY ZPROJECT; DO NOT EDIT EXCEPT EXPERIMENTALLY  #
#  Please refer to the README for information about making permanent changes.  #
################################################################################
*/

#include "qzwebrap.h"

///
//  Copy-construct to return the proper wrapped c types
QZwrClient::QZwrClient (zwr_client_t *self, QObject *qObjParent) : QObject (qObjParent)
{
    this->self = self;
}


///
//  Create a new zwr_client, return the reference if successful, or NULL
//  if construction failed due to lack of available memory.             
QZwrClient::QZwrClient (QObject *qObjParent) : QObject (qObjParent)
{
    this->self = zwr_client_new ();
}

///
//  Destroy the zwr_client and free all memory used by the object.
QZwrClient::~QZwrClient ()
{
    zwr_client_destroy (&self);
}

///
//  Return actor, when caller wants to work with multiple actors and/or
//  input sockets asynchronously.                                      
QZactor * QZwrClient::actor ()
{
    QZactor *rv = new QZactor (zwr_client_actor (self));
    return rv;
}

///
//  Return message pipe for asynchronous message I/O. In the high-volume case,
//  we send methods and get replies to the actor, in a synchronous manner, and
//  we send/recv high volume message data to a second pipe, the msgpipe. In   
//  the low-volume case we can do everything over the actor pipe, if traffic  
//  is never ambiguous.                                                       
QZsock * QZwrClient::msgpipe ()
{
    QZsock *rv = new QZsock (zwr_client_msgpipe (self));
    return rv;
}

///
//  Return true if client is currently connected, else false. Note that the   
//  client will automatically re-connect if the server dies and restarts after
//  a successful first connection.                                            
bool QZwrClient::connected ()
{
    bool rv = zwr_client_connected (self);
    return rv;
}

///
//  Connect to server endpoint, with specified timeout in msecs (zero means wait
//  forever). Constructor succeeds if connection is successful. The caller may  
//  specify its address.                                                        
//  Returns >= 0 if successful, -1 if interrupted.                              
int QZwrClient::connect (const QString &endpoint, quint32 timeout, const QString &address)
{
    int rv = zwr_client_connect (self, endpoint.toUtf8().data(), (uint32_t) timeout, address.toUtf8().data());
    return rv;
}

///
//  Offer to handle particular XRAP requests, where the route matches request's
//  resource.                                                                  
//  Returns >= 0 if successful, -1 if interrupted.                             
int QZwrClient::setHandler (const QString &method, const QString &route)
{
    int rv = zwr_client_set_handler (self, method.toUtf8().data(), route.toUtf8().data());
    return rv;
}

///
//  No explanation                                
//  Returns >= 0 if successful, -1 if interrupted.
int QZwrClient::request (quint32 timeout, QZmsg *contentP)
{
    int rv = zwr_client_request (self, (uint32_t) timeout, &contentP->self);
    return rv;
}

///
//  Send XRAP DELIVER message to server, takes ownership of message
//  and destroys message when done sending it.                     
int QZwrClient::deliver (QZuuid *sender, QZmsg *contentP)
{
    int rv = zwr_client_deliver (self, sender->self, &contentP->self);
    return rv;
}

///
//  Receive message from server; caller destroys message when done
QZmsg * QZwrClient::recv ()
{
    QZmsg *rv = new QZmsg (zwr_client_recv (self));
    return rv;
}

///
//  Return last received command. Can be one of these values:
//      "XRAP DELIVER"                                       
const QString QZwrClient::command ()
{
    const QString rv = QString (zwr_client_command (self));
    return rv;
}

///
//  Return last received status
int QZwrClient::status ()
{
    int rv = zwr_client_status (self);
    return rv;
}

///
//  Return last received reason
const QString QZwrClient::reason ()
{
    const QString rv = QString (zwr_client_reason (self));
    return rv;
}

///
//  Return last received sender
QZuuid * QZwrClient::sender ()
{
    QZuuid *rv = new QZuuid (zwr_client_sender (self));
    return rv;
}

///
//  Return last received content
QZmsg * QZwrClient::content ()
{
    QZmsg *rv = new QZmsg (zwr_client_content (self));
    return rv;
}

///
//  Self test of this class.
void QZwrClient::test (bool verbose)
{
    zwr_client_test (verbose);
    
}
/*
################################################################################
#  THIS FILE IS 100% GENERATED BY ZPROJECT; DO NOT EDIT EXCEPT EXPERIMENTALLY  #
#  Please refer to the README for information about making permanent changes.  #
################################################################################
*/
