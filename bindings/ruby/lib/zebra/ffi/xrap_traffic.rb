################################################################################
#  THIS FILE IS 100% GENERATED BY ZPROJECT; DO NOT EDIT EXCEPT EXPERIMENTALLY  #
#  Read the zproject/README.md for information about making permanent changes. #
################################################################################

module Zebra
  module FFI

    # Set the content field, transferring ownership from caller
    # @note This class is 100% generated using zproject.
    class XrapTraffic
      # 
      SUCCESS = 200

      # 
      STORED = 201

      # 
      DELIVERED = 202

      # 
      NOT_DELIVERED = 300

      # 
      CONTENT_TOO_LARGE = 301

      # 
      TIMEOUT_EXPIRED = 302

      # 
      CONNECTION_REFUSED = 303

      # 
      BAD_REQUEST = 400

      # 
      ACCESS_REFUSED = 401

      # 
      NOT_FOUND = 404

      # 
      METHOD_NOT_ALLOWED = 405

      # 
      NOT_ACCEPTABLE = 406

      # 
      CONFLICT = 409

      # 
      PRECONDITION_FAILED = 412

      # 
      RESOURCE_LOCKED = 423

      # 
      COMMAND_INVALID = 500

      # 
      NOT_IMPLEMENTED = 501

      # 
      INTERNAL_ERROR = 502

      # 
      CONNECTION_OPEN = 1

      # 
      CONNECTION_PING = 2

      # 
      CONNECTION_PONG = 3

      # 
      CONNECTION_CLOSE = 4

      # 
      XRAP_SEND = 5

      # 
      XRAP_OFFER = 6

      # 
      XRAP_DELIVER = 7

      # 
      OK = 8

      # 
      FAIL = 9

      # 
      ERROR = 10

      # Raised when one tries to use an instance of {XrapTraffic} after
      # the internal pointer to the native object has been nullified.
      class DestroyedError < RuntimeError; end

      # Boilerplate for self pointer, initializer, and finalizer
      class << self
        alias :__new :new
      end
      # Attaches the pointer _ptr_ to this instance and defines a finalizer for
      # it if necessary.
      # @param ptr [::FFI::Pointer]
      # @param finalize [Boolean]
      def initialize(ptr, finalize = true)
        @ptr = ptr
        if @ptr.null?
          @ptr = nil # Remove null pointers so we don't have to test for them.
        elsif finalize
          @finalizer = self.class.create_finalizer_for @ptr
          ObjectSpace.define_finalizer self, @finalizer
        end
      end
      # @param ptr [::FFI::Pointer]
      # @return [Proc]
      def self.create_finalizer_for(ptr)
        Proc.new do
          ptr_ptr = ::FFI::MemoryPointer.new :pointer
          ptr_ptr.write_pointer ptr
          ::Zebra::FFI.xrap_traffic_destroy ptr_ptr
        end
      end
      # @return [Boolean]
      def null?
        !@ptr or @ptr.null?
      end
      # Return internal pointer
      # @return [::FFI::Pointer]
      def __ptr
        raise DestroyedError unless @ptr
        @ptr
      end
      # So external Libraries can just pass the Object to a FFI function which expects a :pointer
      alias_method :to_ptr, :__ptr
      # Nullify internal pointer and return pointer pointer.
      # @note This detaches the current instance from the native object
      #   and thus makes it unusable.
      # @return [::FFI::MemoryPointer] the pointer pointing to a pointer
      #   pointing to the native object
      def __ptr_give_ref
        raise DestroyedError unless @ptr
        ptr_ptr = ::FFI::MemoryPointer.new :pointer
        ptr_ptr.write_pointer @ptr
        __undef_finalizer if @finalizer
        @ptr = nil
        ptr_ptr
      end
      # Undefines the finalizer for this object.
      # @note Only use this if you need to and can guarantee that the native
      #   object will be freed by other means.
      # @return [void]
      def __undef_finalizer
        ObjectSpace.undefine_finalizer self
        @finalizer = nil
      end

      # Create a new empty xrap_traffic
      # @return [Zebra::XrapTraffic]
      def self.new()
        ptr = ::Zebra::FFI.xrap_traffic_new()
        __new ptr
      end

      # Destroy a xrap_traffic instance
      #
      # @return [void]
      def destroy()
        return unless @ptr
        self_p = __ptr_give_ref
        result = ::Zebra::FFI.xrap_traffic_destroy(self_p)
        result
      end

      # Receive a xrap_traffic from the socket. Returns 0 if OK, -1 if
      # there was an error. Blocks if there is no message waiting.    
      #
      # @param input [::FFI::Pointer, #to_ptr]
      # @return [Integer]
      def recv(input)
        raise DestroyedError unless @ptr
        self_p = @ptr
        result = ::Zebra::FFI.xrap_traffic_recv(self_p, input)
        result
      end

      # Send the xrap_traffic to the output socket, does not destroy it
      #
      # @param output [::FFI::Pointer, #to_ptr]
      # @return [Integer]
      def send(output)
        raise DestroyedError unless @ptr
        self_p = @ptr
        result = ::Zebra::FFI.xrap_traffic_send(self_p, output)
        result
      end

      # Print contents of message to stdout
      #
      # @return [void]
      def print()
        raise DestroyedError unless @ptr
        self_p = @ptr
        result = ::Zebra::FFI.xrap_traffic_print(self_p)
        result
      end

      # Get the message routing id, as a frame
      #
      # @return [::FFI::Pointer]
      def routing_id()
        raise DestroyedError unless @ptr
        self_p = @ptr
        result = ::Zebra::FFI.xrap_traffic_routing_id(self_p)
        result
      end

      # Set the message routing id from a frame
      #
      # @param routing_id [::FFI::Pointer, #to_ptr]
      # @return [void]
      def set_routing_id(routing_id)
        raise DestroyedError unless @ptr
        self_p = @ptr
        result = ::Zebra::FFI.xrap_traffic_set_routing_id(self_p, routing_id)
        result
      end

      # Get the xrap_traffic message id
      #
      # @return [Integer]
      def id()
        raise DestroyedError unless @ptr
        self_p = @ptr
        result = ::Zebra::FFI.xrap_traffic_id(self_p)
        result
      end

      # Set the xrap_traffic message id
      #
      # @param id [Integer, #to_int, #to_i]
      # @return [void]
      def set_id(id)
        raise DestroyedError unless @ptr
        self_p = @ptr
        id = Integer(id)
        result = ::Zebra::FFI.xrap_traffic_set_id(self_p, id)
        result
      end

      # Get the xrap_traffic message id as printable text
      #
      # @return [String]
      def command()
        raise DestroyedError unless @ptr
        self_p = @ptr
        result = ::Zebra::FFI.xrap_traffic_command(self_p)
        result
      end

      # Get the address field
      #
      # @return [String]
      def address()
        raise DestroyedError unless @ptr
        self_p = @ptr
        result = ::Zebra::FFI.xrap_traffic_address(self_p)
        result
      end

      # Set the address field
      #
      # @param address [String, #to_s, nil]
      # @return [void]
      def set_address(address)
        raise DestroyedError unless @ptr
        self_p = @ptr
        result = ::Zebra::FFI.xrap_traffic_set_address(self_p, address)
        result
      end

      # Get the timeout field
      #
      # @return [Integer]
      def timeout()
        raise DestroyedError unless @ptr
        self_p = @ptr
        result = ::Zebra::FFI.xrap_traffic_timeout(self_p)
        result
      end

      # Set the timeout field
      #
      # @param timeout [Integer, #to_int, #to_i]
      # @return [void]
      def set_timeout(timeout)
        raise DestroyedError unless @ptr
        self_p = @ptr
        timeout = Integer(timeout)
        result = ::Zebra::FFI.xrap_traffic_set_timeout(self_p, timeout)
        result
      end

      # Get a copy of the content field
      #
      # @return [::FFI::Pointer]
      def content()
        raise DestroyedError unless @ptr
        self_p = @ptr
        result = ::Zebra::FFI.xrap_traffic_content(self_p)
        result
      end

      # Get the content field and transfer ownership to caller
      #
      # @return [::FFI::Pointer]
      def get_content()
        raise DestroyedError unless @ptr
        self_p = @ptr
        result = ::Zebra::FFI.xrap_traffic_get_content(self_p)
        result
      end

      # 
      #
      # @param content_p [::FFI::Pointer, #to_ptr]
      # @return [void]
      def set_content(content_p)
        raise DestroyedError unless @ptr
        self_p = @ptr
        result = ::Zebra::FFI.xrap_traffic_set_content(self_p, content_p)
        result
      end

      # Get the route field
      #
      # @return [String]
      def route()
        raise DestroyedError unless @ptr
        self_p = @ptr
        result = ::Zebra::FFI.xrap_traffic_route(self_p)
        result
      end

      # Set the route field
      #
      # @param route [String, #to_s, nil]
      # @return [void]
      def set_route(route)
        raise DestroyedError unless @ptr
        self_p = @ptr
        result = ::Zebra::FFI.xrap_traffic_set_route(self_p, route)
        result
      end

      # Get the method field
      #
      # @return [String]
      def method()
        raise DestroyedError unless @ptr
        self_p = @ptr
        result = ::Zebra::FFI.xrap_traffic_method(self_p)
        result
      end

      # Set the method field
      #
      # @param method [String, #to_s, nil]
      # @return [void]
      def set_method(method)
        raise DestroyedError unless @ptr
        self_p = @ptr
        result = ::Zebra::FFI.xrap_traffic_set_method(self_p, method)
        result
      end

      # Get the sender field
      #
      # @return [::FFI::Pointer]
      def sender()
        raise DestroyedError unless @ptr
        self_p = @ptr
        result = ::Zebra::FFI.xrap_traffic_sender(self_p)
        result
      end

      # Get the sender field and transfer ownership to caller
      #
      # @return [::FFI::Pointer]
      def get_sender()
        raise DestroyedError unless @ptr
        self_p = @ptr
        result = ::Zebra::FFI.xrap_traffic_get_sender(self_p)
        result
      end

      # Set the sender field
      #
      # @param sender_p [::FFI::Pointer, #to_ptr]
      # @return [void]
      def set_sender(sender_p)
        raise DestroyedError unless @ptr
        self_p = @ptr
        result = ::Zebra::FFI.xrap_traffic_set_sender(self_p, sender_p)
        result
      end

      # Get the status_code field
      #
      # @return [Integer]
      def status_code()
        raise DestroyedError unless @ptr
        self_p = @ptr
        result = ::Zebra::FFI.xrap_traffic_status_code(self_p)
        result
      end

      # Set the status_code field
      #
      # @param status_code [Integer, #to_int, #to_i]
      # @return [void]
      def set_status_code(status_code)
        raise DestroyedError unless @ptr
        self_p = @ptr
        status_code = Integer(status_code)
        result = ::Zebra::FFI.xrap_traffic_set_status_code(self_p, status_code)
        result
      end

      # Get the status_reason field
      #
      # @return [String]
      def status_reason()
        raise DestroyedError unless @ptr
        self_p = @ptr
        result = ::Zebra::FFI.xrap_traffic_status_reason(self_p)
        result
      end

      # Set the status_reason field
      #
      # @param status_reason [String, #to_s, nil]
      # @return [void]
      def set_status_reason(status_reason)
        raise DestroyedError unless @ptr
        self_p = @ptr
        result = ::Zebra::FFI.xrap_traffic_set_status_reason(self_p, status_reason)
        result
      end

      # Self test of this class.
      #
      # @param verbose [Boolean]
      # @return [void]
      def self.test(verbose)
        verbose = !(0==verbose||!verbose) # boolean
        result = ::Zebra::FFI.xrap_traffic_test(verbose)
        result
      end
    end
  end
end

################################################################################
#  THIS FILE IS 100% GENERATED BY ZPROJECT; DO NOT EDIT EXCEPT EXPERIMENTALLY  #
#  Read the zproject/README.md for information about making permanent changes. #
################################################################################
