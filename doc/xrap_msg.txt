xrap_msg(3)
===========

NAME
----
xrap_msg - XRAP serialization over ZMTP

SYNOPSIS
--------
----
//  This is a draft class, and may change without notice. It is disabled in
//  stable builds by default. If you use this in applications, please ask
//  for it to be pushed to stable state. Use --enable-drafts to enable.
//  Self test of this class.
ZEBRA_EXPORT void
    xrap_msg_test (bool verbose);


#ifdef ZEBRA_BUILD_DRAFT_API
#define XRAP_MSG_POST 1                     // 
#define XRAP_MSG_POST_OK 2                  // 
#define XRAP_MSG_GET 3                      // 
#define XRAP_MSG_GET_OK 4                   // 
#define XRAP_MSG_GET_EMPTY 5                // 
#define XRAP_MSG_PUT 6                      // 
#define XRAP_MSG_PUT_OK 7                   // 
#define XRAP_MSG_DELETE 8                   // 
#define XRAP_MSG_DELETE_OK 9                // 
#define XRAP_MSG_ERROR 10                   // 

//  *** Draft method, for development use, may change without warning ***
//  Create a new xrap_msg
ZEBRA_EXPORT xrap_msg_t *
    xrap_msg_new (int id);

//  *** Draft method, for development use, may change without warning ***
//  Destroy the xrap_msg
ZEBRA_EXPORT void
    xrap_msg_destroy (xrap_msg_t **self_p);

//  *** Draft method, for development use, may change without warning ***
//  Parse a xrap_msg from zmsg_t. Returns a new object, or NULL if
//  the message could not be parsed, or was NULL. Destroys msg and
//  nullifies the msg reference.                                  
ZEBRA_EXPORT xrap_msg_t *
    xrap_msg_decode (zmsg_t **msg_p);

//  *** Draft method, for development use, may change without warning ***
//  Encode xrap_msg into zmsg and destroy it. Returns a newly created       
//  object or NULL if error. Use when not in control of sending the message.
ZEBRA_EXPORT zmsg_t *
    xrap_msg_encode (xrap_msg_t **xrap_msg_p);

//  *** Draft method, for development use, may change without warning ***
//  Receive and parse a xrap_msg from the socket. Returns new object,
//  or NULL if error. Will block if there's no message waiting.      
ZEBRA_EXPORT xrap_msg_t *
    xrap_msg_recv (void *input);

//  *** Draft method, for development use, may change without warning ***
//  Receive and parse a xrap_msg from the socket. Returns new object,         
//  or NULL either if there was no input waiting, or the recv was interrupted.
ZEBRA_EXPORT xrap_msg_t *
    xrap_msg_recv_nowait (void *input);

//  *** Draft method, for development use, may change without warning ***
//  Send the xrap_msg to the output, and destroy it
ZEBRA_EXPORT int
    xrap_msg_send (xrap_msg_t **self_p, void *output);

//  *** Draft method, for development use, may change without warning ***
//  Send the xrap_msg to the output, and destroy it
ZEBRA_EXPORT int
    xrap_msg_send_again (xrap_msg_t *self, void *output);

//  *** Draft method, for development use, may change without warning ***
//  Get the xrap_msg id and printable command
ZEBRA_EXPORT int
    xrap_msg_id (xrap_msg_t *self);

//  *** Draft method, for development use, may change without warning ***
//  
ZEBRA_EXPORT void
    xrap_msg_set_id (xrap_msg_t *self, int id);

//  *** Draft method, for development use, may change without warning ***
//  Get/set the parent field
ZEBRA_EXPORT const char *
    xrap_msg_parent (xrap_msg_t *self);

//  *** Draft method, for development use, may change without warning ***
//  
ZEBRA_EXPORT void
    xrap_msg_set_parent (xrap_msg_t *self, const char *format, ...) CHECK_PRINTF (2);

//  *** Draft method, for development use, may change without warning ***
//  Get/set the content_type field
ZEBRA_EXPORT const char *
    xrap_msg_content_type (xrap_msg_t *self);

//  *** Draft method, for development use, may change without warning ***
//  
ZEBRA_EXPORT void
    xrap_msg_set_content_type (xrap_msg_t *self, const char *format, ...) CHECK_PRINTF (2);

//  *** Draft method, for development use, may change without warning ***
//  Get/set the parent field
ZEBRA_EXPORT const char *
    xrap_msg_content_body (xrap_msg_t *self);

//  *** Draft method, for development use, may change without warning ***
//  
ZEBRA_EXPORT void
    xrap_msg_set_content_body (xrap_msg_t *self, const char *format, ...) CHECK_PRINTF (2);

//  *** Draft method, for development use, may change without warning ***
//  Get/set the status_code field
ZEBRA_EXPORT uint16_t
    xrap_msg_status_code (xrap_msg_t *self);

//  *** Draft method, for development use, may change without warning ***
//  
ZEBRA_EXPORT void
    xrap_msg_set_status_code (xrap_msg_t *self, uint16_t status_code);

//  *** Draft method, for development use, may change without warning ***
//  Get/set the location field
ZEBRA_EXPORT const char *
    xrap_msg_location (xrap_msg_t *self);

//  *** Draft method, for development use, may change without warning ***
//  
ZEBRA_EXPORT void
    xrap_msg_set_location (xrap_msg_t *self, const char *format, ...) CHECK_PRINTF (2);

//  *** Draft method, for development use, may change without warning ***
//  Get/set the etag field
ZEBRA_EXPORT const char *
    xrap_msg_etag (xrap_msg_t *self);

//  *** Draft method, for development use, may change without warning ***
//  
ZEBRA_EXPORT void
    xrap_msg_set_etag (xrap_msg_t *self, const char *format, ...) CHECK_PRINTF (2);

//  *** Draft method, for development use, may change without warning ***
//  Get/set the date_modified field
ZEBRA_EXPORT uint64_t
    xrap_msg_date_modified (xrap_msg_t *self);

//  *** Draft method, for development use, may change without warning ***
//  
ZEBRA_EXPORT void
    xrap_msg_set_date_modified (xrap_msg_t *self, uint64_t date_modified);

//  *** Draft method, for development use, may change without warning ***
//  Get/set the resource field
ZEBRA_EXPORT const char *
    xrap_msg_resource (xrap_msg_t *self);

//  *** Draft method, for development use, may change without warning ***
//  
ZEBRA_EXPORT void
    xrap_msg_set_resource (xrap_msg_t *self, const char *format, ...) CHECK_PRINTF (2);

//  *** Draft method, for development use, may change without warning ***
//  //  Get/set the parameters field
ZEBRA_EXPORT zhash_t *
    xrap_msg_parameters (xrap_msg_t *self);

//  *** Draft method, for development use, may change without warning ***
//  //  Get the parameters field and transfer ownership to caller
ZEBRA_EXPORT zhash_t *
    xrap_msg_get_parameters (xrap_msg_t *self);

//  *** Draft method, for development use, may change without warning ***
//  
ZEBRA_EXPORT void
    xrap_msg_set_parameters (xrap_msg_t *self, zhash_t **parameters_p);

//  *** Draft method, for development use, may change without warning ***
//  Get/set the parameters field
ZEBRA_EXPORT const char *
    xrap_msg_parameters_string (xrap_msg_t *self, const char *key, const char *default_value);

//  *** Draft method, for development use, may change without warning ***
//  
ZEBRA_EXPORT void
    xrap_msg_parameters_insert (xrap_msg_t *self, const char *key, const char *format, ...) CHECK_PRINTF (3);

//  *** Draft method, for development use, may change without warning ***
//  Get/set the if_modified_since field
ZEBRA_EXPORT uint64_t
    xrap_msg_if_modified_since (xrap_msg_t *self);

//  *** Draft method, for development use, may change without warning ***
//  
ZEBRA_EXPORT void
    xrap_msg_set_if_modified_since (xrap_msg_t *self, uint64_t if_modified_since);

//  *** Draft method, for development use, may change without warning ***
//  Get/set the if_none_match field
ZEBRA_EXPORT const char *
    xrap_msg_if_none_match (xrap_msg_t *self);

//  *** Draft method, for development use, may change without warning ***
//  
ZEBRA_EXPORT void
    xrap_msg_set_if_none_match (xrap_msg_t *self, const char *format, ...) CHECK_PRINTF (2);

//  *** Draft method, for development use, may change without warning ***
//  //  Get/set the metadata field
ZEBRA_EXPORT zhash_t *
    xrap_msg_metadata (xrap_msg_t *self);

//  *** Draft method, for development use, may change without warning ***
//  //  Get the metadata field and transfer ownership to caller
ZEBRA_EXPORT zhash_t *
    xrap_msg_get_metadata (xrap_msg_t *self);

//  *** Draft method, for development use, may change without warning ***
//  
ZEBRA_EXPORT void
    xrap_msg_set_metadata (xrap_msg_t *self, zhash_t **metadata_p);

//  *** Draft method, for development use, may change without warning ***
//  Get/set a value in the metadata dictionary
ZEBRA_EXPORT const char *
    xrap_msg_metadata_string (xrap_msg_t *self, const char *key, const char *default_value);

//  *** Draft method, for development use, may change without warning ***
//  
ZEBRA_EXPORT void
    xrap_msg_metadata_insert (xrap_msg_t *self, const char *key, const char *format, ...) CHECK_PRINTF (3);

//  *** Draft method, for development use, may change without warning ***
//  Get/set the if_unmodified_since field
ZEBRA_EXPORT uint64_t
    xrap_msg_if_unmodified_since (xrap_msg_t *self);

//  *** Draft method, for development use, may change without warning ***
//  
ZEBRA_EXPORT void
    xrap_msg_set_if_unmodified_since (xrap_msg_t *self, uint64_t if_unmodified_since);

//  *** Draft method, for development use, may change without warning ***
//  Get/set the if_match field
ZEBRA_EXPORT const char *
    xrap_msg_if_match (xrap_msg_t *self);

//  *** Draft method, for development use, may change without warning ***
//  
ZEBRA_EXPORT void
    xrap_msg_set_if_match (xrap_msg_t *self, const char *format, ...) CHECK_PRINTF (2);

//  *** Draft method, for development use, may change without warning ***
//  Get/set the status_text field
ZEBRA_EXPORT const char *
    xrap_msg_status_text (xrap_msg_t *self);

//  *** Draft method, for development use, may change without warning ***
//  
ZEBRA_EXPORT void
    xrap_msg_set_status_text (xrap_msg_t *self, const char *format, ...) CHECK_PRINTF (2);


#endif // ZEBRA_BUILD_DRAFT_API
----

DESCRIPTION
-----------

xrap_msg - XRAP serialization over ZMTP

Please add @discuss section in ../src/xrap_msg.c.

EXAMPLE
-------
.From xrap_msg_test method
----
//  Simple create/destroy test
xrap_msg_t *self = xrap_msg_new (0);
assert (self);
xrap_msg_destroy (&self);

//  Create pair of sockets we can send through
zsock_t *input = zsock_new (ZMQ_ROUTER);
assert (input);
zsock_connect (input, "inproc://selftest-xrap_msg");

zsock_t *output = zsock_new (ZMQ_DEALER);
assert (output);
zsock_bind (output, "inproc://selftest-xrap_msg");

//  Encode/send/decode and verify each message type
int instance;
xrap_msg_t *copy;
self = xrap_msg_new (XRAP_MSG_POST);

//  Check that _dup works on empty message
copy = xrap_msg_dup (self);
assert (copy);
xrap_msg_destroy (&copy);

xrap_msg_set_parent (self, "Life is short but Now lasts for ever");
xrap_msg_set_content_type (self, "Life is short but Now lasts for ever");
xrap_msg_set_content_body (self, "Life is short but Now lasts for ever");
//  Send twice from same object
xrap_msg_send_again (self, output);
xrap_msg_send (&self, output);

for (instance = 0; instance < 2; instance++) {
    self = xrap_msg_recv (input);
    assert (self);
    assert (xrap_msg_routing_id (self));

    assert (streq (xrap_msg_parent (self), "Life is short but Now lasts for ever"));
    assert (streq (xrap_msg_content_type (self), "Life is short but Now lasts for ever"));
    assert (streq (xrap_msg_content_body (self), "Life is short but Now lasts for ever"));
    xrap_msg_destroy (&self);
}
self = xrap_msg_new (XRAP_MSG_POST_OK);

//  Check that _dup works on empty message
copy = xrap_msg_dup (self);
assert (copy);
xrap_msg_destroy (&copy);

xrap_msg_set_status_code (self, 123);
xrap_msg_set_location (self, "Life is short but Now lasts for ever");
xrap_msg_set_etag (self, "Life is short but Now lasts for ever");
xrap_msg_set_date_modified (self, 123);
xrap_msg_set_content_type (self, "Life is short but Now lasts for ever");
xrap_msg_set_content_body (self, "Life is short but Now lasts for ever");
xrap_msg_metadata_insert (self, "Name", "Brutus");
xrap_msg_metadata_insert (self, "Age", "%d", 43);
//  Send twice from same object
xrap_msg_send_again (self, output);
xrap_msg_send (&self, output);

for (instance = 0; instance < 2; instance++) {
    self = xrap_msg_recv (input);
    assert (self);
    assert (xrap_msg_routing_id (self));

    assert (xrap_msg_status_code (self) == 123);
    assert (streq (xrap_msg_location (self), "Life is short but Now lasts for ever"));
    assert (streq (xrap_msg_etag (self), "Life is short but Now lasts for ever"));
    assert (xrap_msg_date_modified (self) == 123);
    assert (streq (xrap_msg_content_type (self), "Life is short but Now lasts for ever"));
    assert (streq (xrap_msg_content_body (self), "Life is short but Now lasts for ever"));
    assert (xrap_msg_metadata_size (self) == 2);
    assert (streq (xrap_msg_metadata_string (self, "Name", "?"), "Brutus"));
    assert (xrap_msg_metadata_number (self, "Age", 0) == 43);
    xrap_msg_destroy (&self);
}
self = xrap_msg_new (XRAP_MSG_GET);

//  Check that _dup works on empty message
copy = xrap_msg_dup (self);
assert (copy);
xrap_msg_destroy (&copy);

xrap_msg_set_resource (self, "Life is short but Now lasts for ever");
xrap_msg_parameters_insert (self, "Name", "Brutus");
xrap_msg_parameters_insert (self, "Age", "%d", 43);
xrap_msg_set_if_modified_since (self, 123);
xrap_msg_set_if_none_match (self, "Life is short but Now lasts for ever");
xrap_msg_set_content_type (self, "Life is short but Now lasts for ever");
//  Send twice from same object
xrap_msg_send_again (self, output);
xrap_msg_send (&self, output);

for (instance = 0; instance < 2; instance++) {
    self = xrap_msg_recv (input);
    assert (self);
    assert (xrap_msg_routing_id (self));

    assert (streq (xrap_msg_resource (self), "Life is short but Now lasts for ever"));
    assert (xrap_msg_parameters_size (self) == 2);
    assert (streq (xrap_msg_parameters_string (self, "Name", "?"), "Brutus"));
    assert (xrap_msg_parameters_number (self, "Age", 0) == 43);
    assert (xrap_msg_if_modified_since (self) == 123);
    assert (streq (xrap_msg_if_none_match (self), "Life is short but Now lasts for ever"));
    assert (streq (xrap_msg_content_type (self), "Life is short but Now lasts for ever"));
    xrap_msg_destroy (&self);
}
self = xrap_msg_new (XRAP_MSG_GET_OK);

//  Check that _dup works on empty message
copy = xrap_msg_dup (self);
assert (copy);
xrap_msg_destroy (&copy);

xrap_msg_set_status_code (self, 123);
xrap_msg_set_etag (self, "Life is short but Now lasts for ever");
xrap_msg_set_date_modified (self, 123);
xrap_msg_set_content_type (self, "Life is short but Now lasts for ever");
xrap_msg_set_content_body (self, "Life is short but Now lasts for ever");
xrap_msg_metadata_insert (self, "Name", "Brutus");
xrap_msg_metadata_insert (self, "Age", "%d", 43);
//  Send twice from same object
xrap_msg_send_again (self, output);
xrap_msg_send (&self, output);

for (instance = 0; instance < 2; instance++) {
    self = xrap_msg_recv (input);
    assert (self);
    assert (xrap_msg_routing_id (self));

    assert (xrap_msg_status_code (self) == 123);
    assert (streq (xrap_msg_etag (self), "Life is short but Now lasts for ever"));
    assert (xrap_msg_date_modified (self) == 123);
    assert (streq (xrap_msg_content_type (self), "Life is short but Now lasts for ever"));
    assert (streq (xrap_msg_content_body (self), "Life is short but Now lasts for ever"));
    assert (xrap_msg_metadata_size (self) == 2);
    assert (streq (xrap_msg_metadata_string (self, "Name", "?"), "Brutus"));
    assert (xrap_msg_metadata_number (self, "Age", 0) == 43);
    xrap_msg_destroy (&self);
}
self = xrap_msg_new (XRAP_MSG_GET_EMPTY);

//  Check that _dup works on empty message
copy = xrap_msg_dup (self);
assert (copy);
xrap_msg_destroy (&copy);

xrap_msg_set_status_code (self, 123);
//  Send twice from same object
xrap_msg_send_again (self, output);
xrap_msg_send (&self, output);

for (instance = 0; instance < 2; instance++) {
    self = xrap_msg_recv (input);
    assert (self);
    assert (xrap_msg_routing_id (self));

    assert (xrap_msg_status_code (self) == 123);
    xrap_msg_destroy (&self);
}
self = xrap_msg_new (XRAP_MSG_PUT);

//  Check that _dup works on empty message
copy = xrap_msg_dup (self);
assert (copy);
xrap_msg_destroy (&copy);

xrap_msg_set_resource (self, "Life is short but Now lasts for ever");
xrap_msg_set_if_unmodified_since (self, 123);
xrap_msg_set_if_match (self, "Life is short but Now lasts for ever");
xrap_msg_set_content_type (self, "Life is short but Now lasts for ever");
xrap_msg_set_content_body (self, "Life is short but Now lasts for ever");
//  Send twice from same object
xrap_msg_send_again (self, output);
xrap_msg_send (&self, output);

for (instance = 0; instance < 2; instance++) {
    self = xrap_msg_recv (input);
    assert (self);
    assert (xrap_msg_routing_id (self));

    assert (streq (xrap_msg_resource (self), "Life is short but Now lasts for ever"));
    assert (xrap_msg_if_unmodified_since (self) == 123);
    assert (streq (xrap_msg_if_match (self), "Life is short but Now lasts for ever"));
    assert (streq (xrap_msg_content_type (self), "Life is short but Now lasts for ever"));
    assert (streq (xrap_msg_content_body (self), "Life is short but Now lasts for ever"));
    xrap_msg_destroy (&self);
}
self = xrap_msg_new (XRAP_MSG_PUT_OK);

//  Check that _dup works on empty message
copy = xrap_msg_dup (self);
assert (copy);
xrap_msg_destroy (&copy);

xrap_msg_set_status_code (self, 123);
xrap_msg_set_location (self, "Life is short but Now lasts for ever");
xrap_msg_set_etag (self, "Life is short but Now lasts for ever");
xrap_msg_set_date_modified (self, 123);
xrap_msg_metadata_insert (self, "Name", "Brutus");
xrap_msg_metadata_insert (self, "Age", "%d", 43);
//  Send twice from same object
xrap_msg_send_again (self, output);
xrap_msg_send (&self, output);

for (instance = 0; instance < 2; instance++) {
    self = xrap_msg_recv (input);
    assert (self);
    assert (xrap_msg_routing_id (self));

    assert (xrap_msg_status_code (self) == 123);
    assert (streq (xrap_msg_location (self), "Life is short but Now lasts for ever"));
    assert (streq (xrap_msg_etag (self), "Life is short but Now lasts for ever"));
    assert (xrap_msg_date_modified (self) == 123);
    assert (xrap_msg_metadata_size (self) == 2);
    assert (streq (xrap_msg_metadata_string (self, "Name", "?"), "Brutus"));
    assert (xrap_msg_metadata_number (self, "Age", 0) == 43);
    xrap_msg_destroy (&self);
}
self = xrap_msg_new (XRAP_MSG_DELETE);

//  Check that _dup works on empty message
copy = xrap_msg_dup (self);
assert (copy);
xrap_msg_destroy (&copy);

xrap_msg_set_resource (self, "Life is short but Now lasts for ever");
xrap_msg_set_if_unmodified_since (self, 123);
xrap_msg_set_if_match (self, "Life is short but Now lasts for ever");
//  Send twice from same object
xrap_msg_send_again (self, output);
xrap_msg_send (&self, output);

for (instance = 0; instance < 2; instance++) {
    self = xrap_msg_recv (input);
    assert (self);
    assert (xrap_msg_routing_id (self));

    assert (streq (xrap_msg_resource (self), "Life is short but Now lasts for ever"));
    assert (xrap_msg_if_unmodified_since (self) == 123);
    assert (streq (xrap_msg_if_match (self), "Life is short but Now lasts for ever"));
    xrap_msg_destroy (&self);
}
self = xrap_msg_new (XRAP_MSG_DELETE_OK);

//  Check that _dup works on empty message
copy = xrap_msg_dup (self);
assert (copy);
xrap_msg_destroy (&copy);

xrap_msg_set_status_code (self, 123);
xrap_msg_metadata_insert (self, "Name", "Brutus");
xrap_msg_metadata_insert (self, "Age", "%d", 43);
//  Send twice from same object
xrap_msg_send_again (self, output);
xrap_msg_send (&self, output);

for (instance = 0; instance < 2; instance++) {
    self = xrap_msg_recv (input);
    assert (self);
    assert (xrap_msg_routing_id (self));

    assert (xrap_msg_status_code (self) == 123);
    assert (xrap_msg_metadata_size (self) == 2);
    assert (streq (xrap_msg_metadata_string (self, "Name", "?"), "Brutus"));
    assert (xrap_msg_metadata_number (self, "Age", 0) == 43);
    xrap_msg_destroy (&self);
}
self = xrap_msg_new (XRAP_MSG_ERROR);

//  Check that _dup works on empty message
copy = xrap_msg_dup (self);
assert (copy);
xrap_msg_destroy (&copy);

xrap_msg_set_status_code (self, 123);
xrap_msg_set_status_text (self, "Life is short but Now lasts for ever");
//  Send twice from same object
xrap_msg_send_again (self, output);
xrap_msg_send (&self, output);

for (instance = 0; instance < 2; instance++) {
    self = xrap_msg_recv (input);
    assert (self);
    assert (xrap_msg_routing_id (self));

    assert (xrap_msg_status_code (self) == 123);
    assert (streq (xrap_msg_status_text (self), "Life is short but Now lasts for ever"));
    xrap_msg_destroy (&self);
}

zsock_destroy (&input);
zsock_destroy (&output);
----
